
# ğŸ“˜ Pact Contract Testing â€“ Endâ€‘toâ€‘End Guide

This document is designed to be used as:
- ğŸ“š Onboarding documentation
- ğŸ¤ KT / knowledgeâ€‘sharing presentation material
- ğŸ§ª Reference for writing Pact consumer & provider tests
- ğŸš€ CI/CD integration guide

---

## 1ï¸âƒ£ Why Contract Testing?

In microservices architectures:
- Services evolve independently
- APIs change frequently
- Traditional integration & E2E tests are slow and brittle

### Problems without Pact
- Breaking API changes discovered too late
- Tight coupling between teams
- Expensive shared test environments
- Hardâ€‘toâ€‘debug failures

### Pact Solution
**Consumerâ€‘Driven Contract Testing (CDCT)** ensures:
- Consumers define expectations
- Providers verify compatibility
- CI blocks breaking changes early

---

## 2ï¸âƒ£ Core Pact Concepts

| Concept | Description |
|------|-------------|
| Consumer | Service that calls another service |
| Provider | Service that exposes APIs |
| Pact File | JSON contract generated by consumer tests |
| Interaction | One request/response expectation |
| Provider State | Named condition required by provider |
| Verification | Provider validates contract against real API |

---

## 3ï¸âƒ£ Highâ€‘Level Architecture

```
Consumer Test (TS / Node / Nx)
        |
        | 1. Define expectations
        v
+-------------------+
| Pact Mock Server  |
+-------------------+
        |
        | 2. Generate Pact File
        v
+-------------------+
| Pact JSON Contract|
+-------------------+
        |
        | 3. Publish (GCS / Broker)
        v
Provider Verification (Java / Spring Boot)
```

---

## 4ï¸âƒ£ Consumer Testing (TypeScript / Node / Nx)

### Key Points
- Pact automatically starts a mock HTTP server
- Consumer tests call real client code
- Tests **pass or fail like normal tests**
- Pact file is generated **only if tests pass**

### Example Test

```ts
import { Pact } from '@pact-foundation/pact';

const provider = new Pact({
  consumer: 'PaymentService',
  provider: 'BookingService',
  port: 1234,
  dir: 'pacts'
});

describe('Payment â†’ Booking', () => {
  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());

  beforeAll(async () => {
    await provider.addInteraction({
      state: 'booking with id 123 exists',
      uponReceiving: 'a booking request',
      withRequest: {
        method: 'GET',
        path: '/bookings/123'
      },
      willRespondWith: {
        status: 200,
        body: { id: 123, status: 'CONFIRMED' }
      }
    });
  });

  it('fetches booking', async () => {
    const booking = await getBookingById(
      provider.mockService.baseUrl,
      123
    );
    expect(booking.status).toBe('CONFIRMED');
  });
});
```

---

## 5ï¸âƒ£ Provider States

### What is a Provider State?
A **provider state** describes the condition the provider must be in before an interaction runs.

Example:
```json
"providerStates": [
  { "name": "booking with id 123 exists" }
]
```

### Consumer Responsibility
- Define provider states in pact tests
- Use businessâ€‘meaningful names

### Provider Responsibility
- Implement matching state handlers

---

## 6ï¸âƒ£ Provider Testing (Spring Boot / Java)

### Characteristics
- Runs real provider application
- No mocks for API endpoints
- Uses contract to drive HTTP calls
- Can reuse existing Spring Boot integration test setup

### Example Provider Test

```java
@SpringBootTest(webEnvironment = RANDOM_PORT)
@Provider("BookingService")
@PactFolder("pacts")
class BookingPactProviderTest {

  @LocalServerPort
  int port;

  @BeforeEach
  void setup(PactVerificationContext context) {
    context.setTarget(new HttpTestTarget("localhost", port));
  }

  @TestTemplate
  @ExtendWith(PactVerificationInvocationContextProvider.class)
  void verify(PactVerificationContext context) {
    context.verifyInteraction();
  }

  @State("booking with id 123 exists")
  void bookingExists() {
    // setup DB or mocks
  }
}
```

---

## 7ï¸âƒ£ What Happens During Verification?

For **each interaction** in the pact file:

1. Provider state handler runs
2. Pact builds HTTP request from contract
3. Request is sent to real API
4. Response is validated
5. Failure blocks build

---

## 8ï¸âƒ£ CI/CD Integration

### Consumer Pipeline

```
nx test consumer
â†“
Pact mock verification
â†“
Generate pact file
â†“
Upload to GCS / Broker
```

### Provider Pipeline

```
Checkout
â†“
Run unit + integration tests
â†“
Start provider app
â†“
Download pact files
â†“
Run Pact verification
â†“
IF PASS â†’ build & deploy
IF FAIL â†’ stop pipeline
```

### Example GitHub Actions Step

```yaml
- name: Verify Pact Contracts
  run: ./gradlew pactVerify
```

---

## 9ï¸âƒ£ Common Questions

### Do consumers only generate contracts?
âŒ No â€” consumer Pact tests **pass or fail** like normal tests.

### Does provider need all services running?
âŒ No â€” only the provider service runs.

### Does Pact test all endpoints?
âŒ Only endpoints defined in contracts.

---

## ğŸ”Ÿ Best Practices

### Consumers
âœ” Small, focused interactions  
âœ” Real client code  
âœ” Clear provider states  

### Providers
âœ” One handler per state  
âœ” Reuse integration test patterns  
âœ” Verify contracts on every PR  

### Teams
âœ” Treat contracts as APIs  
âœ” Block breaking changes early  
âœ” Automate everything  

---

## ğŸ¯ Summary

Pact testing ensures:
- Fast feedback
- Safe independent deployments
- Clear ownership between teams
- Strong API contracts

**Consumers define expectations.  
Providers guarantee compatibility.  
CI enforces trust.**

---

End of document.
